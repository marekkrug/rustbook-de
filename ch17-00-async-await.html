<!DOCTYPE HTML>
<html lang="de" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async und Await - Die Programmiersprache Rust</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>


                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="async-und-await"><a class="header" href="#async-und-await">Async und Await</a></h2>
<p>Viele Operationen, die wir einen Computer ausführen lassen, können eine Weile
dauern, bis sie erledigt sind. Wenn du beispielsweise mit einem Video-Editor
ein Video einer Familienfeier exportierst, kann das Minuten bis Stunden dauern.
Auch das Herunterladen eines Videos, das jemand aus deiner Familie freigegeben
hat, kann lange dauern. Es wäre schön, wenn wir etwas anderes tun könnten,
während wir darauf warten, dass dieser langwierige Vorgang abgeschlossen wird.</p>
<p>Der Videoexport wird so viel CPU- und GPU-Leistung wie möglich beanspruchen.
Wenn du nur über <em>einen</em> CPU-Kern verfügst und dein Betriebssystem den Export
nie pausiert, bis er abgeschlossen ist, kannst du in der Zeit nichts anderes
auf deinem Computer machen. Das wäre allerdings eine ziemlich frustrierende
Erfahrung. Stattdessen kann und wird das Betriebssystem deines Computers den
Export oft genug unmerkbar unterbrechen, damit du währenddessen andere Aufgaben
erledigen kannst.</p>
<p>Der Dateidownload wirkt sich anders aus. Er beansprucht nicht sehr viel
CPU-Zeit. Stattdessen muss die CPU auf das Eintreffen der Daten aus dem
Netzwerk warten. Obwohl du mit dem Einlesen der Daten beginnen kannst, sobald
die ersten Daten angekommen sind, kann es eine Weile dauern, bis der Rest
angekommen ist. Selbst wenn alle Daten bereits angekommen sind, kann ein Video
recht groß sein, sodass es einige Zeit dauern kann, bis alle Daten eingelesen
wurden. Vielleicht dauert es nur ein oder zwei Sekunden, aber das ist eine sehr
lange Zeit für einen modernen Prozessor, der in jeder Sekunde Milliarden von
Operationen ausführen kann. Es wäre schön, wenn man die CPU für andere Aufgaben
nutzen könnte, während man auf das Ende des Netzwerkaufrufs wartet. Auch hier
unterbricht das Betriebssystem das Programm unmerkbar, damit andere Dinge
gemacht werden können, während der Netzwerkvorgang andauert.</p>
<blockquote>
<p>Hinweis: Der Videoexport ist ein Vorgang, der als „CPU-gebunden“ (CPU-bound)
oder „rechengebunden“ (compute-bound) bezeichnet wird. Er ist begrenzt durch
die Geschwindigkeit, mit der der Computer Daten innerhalb der <em>CPU</em> oder
<em>GPU</em> verarbeiten kann, und wie viel von dieser Geschwindigkeit er nutzen
kann. Das Herunterladen von Videos ist hingegen ein Vorgang, der als
„E/A-gebunden“ (I/O bound) bezeichnet wird, weil er durch die Geschwindigkeit
der <em>Eingabe und Ausgabe</em> des Computers begrenzt ist. Es kann nur so schnell
gehen, wie die Daten über das Netzwerk gesendet werden können.</p>
</blockquote>
<p>In beiden Beispielen bieten die unmerkbaren Unterbrechungen des Betriebssystems
eine Form der Nebenläufigkeit. Diese Nebenläufigkeit findet jedoch nur auf der
Ebene eines Programms statt: Das Betriebssystem unterbricht ein Programm, damit
andere Programme ihre Arbeit erledigen können. Da wir unsere Programme in
vielen Fällen auf einer viel detailliertere Ebene verstehen als das
Betriebssystem, können wir viele Möglichkeiten für Nebenläufigkeit sehen, die
das Betriebssystem nicht erkennen kann.</p>
<p>Wenn wir beispielsweise ein Werkzeug zur Verwaltung von Dateidownloads
entwickeln, sollten wir unser Programm so schreiben können, dass der Start
eines Downloads die Benutzeroberfläche nicht blockiert, und die Benutzer
sollten mehrere Downloads gleichzeitig starten können. Viele
Betriebssystem-APIs zur Interaktion mit dem Netzwerk sind jedoch <em>blockierend</em>.
Das heißt, diese APIs blockieren den Programmfortschritt, bis die Daten, die
sie verarbeiten, vollständig verfügbar sind.</p>
<blockquote>
<p>Hinweis: So funktionieren die <em>meisten</em> Funktionsaufrufe, wenn du darüber
nachdenkst! Wir denken beim Begriff „blockierend“ jedoch normalerweise an
Funktionsaufrufe, die mit Dateien, dem Netzwerk oder anderen Ressourcen auf
dem Computer interagieren, weil dies Stellen sind, an denen ein individuelles
Programm davon profitieren würde, wenn die Operation <em>nicht</em> blockierend
wäre.</p>
</blockquote>
<p>Wir könnten das Blockieren unseres Haupt-Strangs (main thread) vermeiden, indem
wir für das Herunterladen jeder Datei einen eigenen Strang (thread) starten.
Allerdings würden wir irgendwann feststellen, dass der Overhead dieser Stränge
ein Problem darstellt. Es wäre auch besser, wenn der Aufruf gar nicht erst
blockieren würde. Und nicht zuletzt wäre es besser, wenn wir in demselben
direkten Stil schreiben könnten, den wir bei blockierendem Code verwenden. So
ähnlich wie hier:</p>
<pre><code class="language-rust ignore does_not_compile">let data = fetch_data_from(url).await;
println!("{data}");</code></pre>
<p>Genau das bietet uns die asynchrone Abstraktion von Rust. Bevor wir uns jedoch
ansehen, wie dies in der Praxis funktioniert, müssen wir einen kleinen
Abstecher zu den Unterschieden zwischen Parallelität und Nebenläufigkeit
machen.</p>
<h3 id="parallelität-und-nebenläufigkeit"><a class="header" href="#parallelität-und-nebenläufigkeit">Parallelität und Nebenläufigkeit</a></h3>
<p>Im vorigen Kapitel haben wir Parallelität und Nebenläufigkeit als weitgehend
gleichbedeutend behandelt. Jetzt müssen wir genauer zwischen ihnen
unterscheiden, denn die Unterschiede werden sich bei der Arbeit zeigen.</p>
<p>Schauen wir uns verschiedene Möglichkeiten an, wie ein Team die Arbeit an einem
Softwareprojekt aufteilen kann. Wir könnten einer einzelnen Person mehrere
Aufgaben zuweisen oder jedem Teammitglied eine Aufgabe oder eine Mischung aus
beiden Ansätzen.</p>
<p>Wenn eine Person an mehreren verschiedenen Aufgaben arbeitet, bevor eine von
ihnen abgeschlossen ist, handelt es sich um <em>Nebenläufigkeit</em>. Vielleicht hast
du zwei verschiedene Projekte auf deinem Computer ausgecheckt, und wenn dir bei
einem Projekt langweilig wird oder du nicht weiterkommst, wechsle zum anderen.
Da du nur <em>eine</em> Person bist, kannst du nicht an beiden Aufgaben gleichzeitig
arbeiten, aber du kannst Multitasking betreiben, d.h. du kannst an mehreren
Aufgaben arbeiten, indem du zwischen ihnen wechselst.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-01.svg" class="center" />
<p><span class="caption">Abbildung 17-1: Ein nebenläufiger Arbeitsablauf, der
zwischen Aufgabe A und Aufgabe B wechselt.</span></p>
<p>Wenn man sich darauf einigt, eine Gruppe von Aufgaben unter den Teammitgliedern
aufzuteilen, wobei jede Person eine Aufgabe übernimmt und allein bearbeitet,
ist das <em>Parallelität</em>. Jede Person im Team kann genau zur gleichen Zeit
Fortschritte machen.</p>
<img alt="Gleichzeitiger Arbeitsablauf" src="img/trpl17-02.svg" class="center" />
<p><span class="caption">Abbildung 17-2: Ein paralleler Arbeitsablauf, bei dem die
Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt.</span></p>
<p>In diesen beiden Situationen musst du dich möglicherweise zwischen
verschiedenen Aufgaben abstimmen. Vielleicht hast du <em>gedacht</em>, dass die
Aufgabe, an der eine Person arbeitet, völlig unabhängig von der Arbeit der
anderen ist, aber sie muss von einer anderen Person im Team erledigt werden.
Ein Teil der Arbeit könnte parallel erledigt werden, aber ein Teil der Arbeit
war eigentlich <em>sequentiell</em>: Sie konnte nur nacheinander stattfinden, eins
nach dem anderen, wie in Abbildung 17-3.</p>
<img alt="Nebenläufiger Arbeitsablauf" src="img/trpl17-03.svg" class="center" />
<p><span class="caption">Abbildung 17-3: Ein teilweise paralleler Arbeitsablauf,
bei dem die Arbeit an Aufgabe A und Aufgabe B unabhängig voneinander erfolgt,
bis Aufgabe A3 durch die Ergebnisse von Aufgabe B3 blockiert wird.</span></p>
<p>Ebenso könntest du feststellen, dass eine deiner eigenen Aufgaben von einer
anderen deiner Aufgaben abhängt. Jetzt ist deine gleichzeitige Arbeit auch
sequentiell geworden.</p>
<p>Parallelität und Nebenläufigkeit können sich auch gegenseitig überschneiden.
Wenn du erfährst, dass ein Kollege nicht weiterkommt, bis du eine deiner
Aufgaben beendet hast, wirst du dich wahrscheinlich ganz auf diese Aufgabe
konzentrieren, um deinen Kollegen nicht zu blockieren. Du und dein Kollege
können nicht mehr parallel arbeiten, und du könntest auch nicht mehr
nebenläufig an deinen eigenen Aufgaben arbeiten.</p>
<p>Die gleiche grundlegende Dynamik kommt bei Software und Hardware zum Tragen.
Auf einem Rechner mit einem einzigen CPU-Kern kann die CPU nur eine Operation
zur gleichen Zeit ausführen, aber sie kann dennoch nebenläufig arbeiten.
Mithilfe von Werkzeugen wie Strängen, Prozessen und async kann der Computer
eine Aktivität unterbrechen und zu einer anderen wechseln, bis er schließlich
wieder zur ersten Aktivität zurückkehrt. Auf einem Computer mit mehreren
CPU-Kernen kann er auch parallel arbeiten. Ein Kern kann eine Sache erledigen,
während ein anderer Kern etwas völlig anderes tut, und das sogar zur gleichen
Zeit.</p>
<p>Wenn wir mit async in Rust arbeiten, haben wir es immer mit Nebenläufigkeit zu
tun. Abhängig von der Hardware, dem Betriebssystem und der verwendeten
asynchronen Laufzeitumgebung kann diese Nebenläufigkeit auch Parallelität unter
der Haube nutzen.</p>
<p>Jetzt wollen wir uns ansehen, wie die asynchrone Programmierung in Rust
tatsächlich funktioniert! Im weiteren Verlauf dieses Kapitels werden wir:</p>
<ul>
<li>sehen, wie man Rusts <code>async</code> und <code>await</code> Syntax verwendet.</li>
<li>erkunden, wie man das asynchrone Modell verwendet, um einige der
Herausforderungen zu lösen, die wir in Kapitel 16 betrachtet haben.</li>
<li>uns anschauen, wie Mehrsträngigkeit (multithreading) und async komplementäre
Lösungen bieten, die man in vielen Fällen sogar zusammen verwenden kann.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch16-04-extensible-concurrency-sync-and-send.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-01-futures-and-syntax.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>



        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/ferris.js"></script>


    </div>
    </body>
</html>
